<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="Caio's Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Caio's Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Caio's Blog">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>


  <title> Caio's Blog </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Caio's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">生命不息，作死不止</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/15/ChatCellBubbleDesign/" itemprop="url">
                  聊天气泡的代码结构设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-10-15T18:01:21+08:00" content="2017-10-15">
              2017-10-15
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">一个IM最核心的就是聊天，而聊天展现在用户面前的，简单的来说就是一个聊天列表+一个输入功能区（俗称inputbar）。而聊天列表中，聊天泡泡的设计必然就显得尤为重要。有人说，这有什么好设计的，无非就是一个个UITableViewCell而已啊。但是细想一下，一个好的设计不应该只是为了满足当前的需求。一个好的设计一方面，需要可以满足随时添加新的需求而不需要很大很复杂的工作量，另一方面，在其他同事拿到你的代码之后可以很快速的上手。</div></pre></td></tr></table></figure>
<p>###前序<br>在现有的项目中的聊天气泡的实现过于“粗暴”。何为“粗暴”，一个cell的实现类，囊括了所有类型的气泡（普通文本，单图，多图，图文混排，语音，红包，名片，链接…）。导致这个类的体型巨大无比，以至于，这个类已经没有办法看懂了，更别说开发。</p>
<p>###聊天气泡的重新设计<br>那气泡的设计有没有好的解决方案呢？答案肯定是有的。</p>
<p>考虑一下，设计一个聊天气泡，我们应该要满足那些基本的需求呢？</p>
<ol>
<li>首先，不同类型的cell的实现肯定是需要分离的。在一个类中实现，无论如何都是违背设计原理的。</li>
<li>其次，需要满足可以随时增加一个新的类型的气泡。但是！不应该在原有的气泡上做更多的改动。</li>
<li>一个好的设计的项目，必然是会涉及到模块化的。那么，一个好的设计的气泡，必然也要支持在不同的模块中定义气泡。（举个例子，如果有一个新的红包的模块，那么这个红包的模块应该在模块内部去自定义一个气泡类型，并且由它自己实现。而不应该去改动其他模块的内容）。</li>
<li>在满足以上条件的时候很有可能会出现很大冗余的代码，如何避免气泡实现中的冗余代码也是一个需要仔细考虑的问题。</li>
<li>如果能满足以上4个需求的话基本上是一个比较好的设计了。但是精益求精，cell的实现可以用代码，也可以用XIB，那么，在实现上是否可以兼容两个的实现呢？</li>
</ol>
<p>###聊天气泡的设计实现<br>在考虑很久并且改了又改的状态下，第一版重新设计的气泡实现终于出来了。</p>
<p>####整体设计<br>首先，在大的框架上，采用注册查询的方式实现聊天气泡的类型分类。在气泡实现的模块A中，使用一个全局的单例（CellTypeAdapter），这个单例使用KV模式，负责管理所有的气泡设计和实现。当然这个类会被公开出去，以便于其他模块（B,C）实现的气泡向这个adapter注册。这个可以解决以上需求中的第3点。</p>
<p>####细节设计<br>然后，我们再细化设计。具体的气泡是怎么实现呢？曾考虑过一个气泡直接从UITableViewCell继承。但是这样的话对于一个气泡的实现“权限过大”，主实现没有办法控制气泡的内容，并且，最主要的一点是，代码的冗余太大了。</p>
<p>最终决定，不同的气泡使用同一个cell类。其实Tableview对于每一个cell需要知道的信息是cell的高度，以及cell的内容View而已。</p>
<p>构建一个protocol 这个protocol是每一个类型的气泡需要实现的，我们暂且称这个实现为一个cellBuilder，这个protocol叫builderProtocol吧。cell需要知道的信息就向实现了这个protocol的指定cellBuilder get。<br>举个例子：如果现在tableview需要知道一个文本消息类型的高度。那么这个tableview就可以向CellTypeAdapter中获取到这个文本消息类型Key对应的builder，然后根据protocol所定义的，传递必要的信息（消息内容，最小高度，最大宽度等等），由builder计算并向tableview返回它自己的高度。（当让如果你使用自动高度的话，这个可以忽略，不过自动高度会有问题，这个可以考虑再出个文章）。<br>再举个例子：如果现在tableview需要在cellFor…返回cell对象。那么tableview同样向cell传递必要的信息，cell拿到信息之后，再从信息中获取当前的消息类型，拿到对应的builder，再通过protocol协议传给builder cell的contentView和必要的信息，由builder自己在这个生命周期中往cell的contentView绘制添加控件。<br>如果这么实现的话，那么向CellTypeAdapter单例中注册的就不是cell，而应该是一个一个builder。</p>
<p>####再细节设计<br>这么看起来好像似乎已经没有问题了，上面的1和3也可以满足了，但是问题又来了…<br>如果现在有一个普通文本消息，有一个图片消息。我们知道，消息边上一般会带有头像，名字，那么根据上面这个设计，会有两个builder，一个txtcellbuilder，一个imgcellbuilder。这两个builder就都需要做头像，名字的绘制。<br>使用基类？给谁设计基类？builder，如果给builder设计基类的话，这个基类放在哪？气泡的主实现模块中？然后公开头文件吗？如果有一个新的共性怎么办？去改动这个基类吗？给cell设计基类也是同样的问题。基类，在支持模块化上并不是很好的选择。这就是我们上面所说的第4个问题。</p>
<p>为了解决这个问题，我们在cell层和builder层之间引入一个新的同样是注册查询使用的CellTemplateAdpater。顾名思义，这个adapt是一个模板单例。和CellTypeAdapter的意义和使用一样，也是个全局单例。同样定义一个新的templateProtocol，这个protocol是不同的模板需要实现的协议。而在builder实现的builderProtocol中，新增一个新的方法。方法返回该builder使用的模板类型。</p>
<p>这样一来，细节设计中的例子流程就会有所变化了。同样的例子：<br>在tableview需要知道高度的时候，tableview同样的拿到该消息对应的builder，但是同时根据builderProtocol中返回的模板类型，生成一个这个builder使用的模板，并且给予必要的信息（builder，和上面说的那些信息），向模板索要高度，不同的模板可以构建不同的UI框架，比如，在大部分消息气泡中一般来说是，一个头像，一个名字，一个可以伸缩的气泡。那么此时模板再向builder索取builder的size。注意此时builder的size应该是刨去模板中的已经创建的UIView了。比如：只包含伸缩气泡中内容的大小。模板template拿到builder的size之后再计算自己已经绘制的view的size，做merge之后返回给tableview。<br>绘制view的时候也是同样的道理，上面的例子中说绘制的时候cell会把contentView传递给builder，但现在是传递给对应的template,由对应的模板选择给builder哪一块区域去绘制。</p>
<p>这样一来第4个问题就解决了。相似的气泡可以使用同一个模板，而气泡内容只要关注于自己特性的那一片区域就可以了。</p>
<p>####再再细节设计<br>到这里，其实上面的四个问题都可以解决了，第5个需求其实在实现中就会慢慢体现出来。</p>
<p>在adapter中注册的类型问题：<br>在CellTypeAdapter 中注册的key必然应该是消息的类型，value应该是string类型，这个string应该是builder的className。之前设计的时候没有考虑这个，value给了builder对象，导致所有同一个类型的气泡都由一个对象去生成View给template，导致消息数据没有办法存储，而出现用户在View中做了交互之后没有办法做数据处理。<br>所以在value中给了string，而tableview或者cell中获取builder的时候由className动态生成builder对象，这样就变成了，一个cell对象对应一个builder对象</p>
<p>模板也是如此，模板中也存在很多控件，头像的点击…，同理模板的注册也使用className，key则使用了模板自定的identity（一个extern string）。那么builder在定义使用的模板的时候，即实现templateProtocol的时候。需要返回模板导出的这个identify。</p>
<p>###总结<br>这样一来，一个cell 对象包含一个template对象和一个builder对象，可以解决以上5个问题了吧。。当然还需要在实践中验证这个设计的合理之处与不合理之处。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/21/GCD-dispatch-once性能探究/" itemprop="url">
                  GCD-dispatch_once性能探究
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-09-21T13:36:13+08:00" content="2017-09-21">
              2017-09-21
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h3><p>dispatch_once是GCD中常用来在iOS中构建单例。一般的构建方式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static dispatch_once_t oncetoken;</div><div class="line">dispatch_once(&amp;oncetoken, ^&#123;</div><div class="line">    // some one-time task</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>今天正好看到一篇文章,还是比较有深度<br><a href="http://www.dreamingwish.com/article/gcd-guide-dispatch-once-1.html" target="_blank" rel="external">GCD外传：dispatch_once(上)</a><br>这篇文章主要探究了dispatch_once的性能上的实现，以及通过几种方法模拟了dispatch_once的实现。</p>
<p>在看文章的过程中，我突然想起了java中的单例的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private volatile static Singleton _instance;</div><div class="line">   public static Singleton getInstanceDC() &#123;</div><div class="line">        if (_instance == null) &#123;</div><div class="line">            synchronized (Singleton.class) &#123;</div><div class="line">                if (_instance == null) &#123;</div><div class="line">                    _instance = new Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return _instance;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>其中_instance是需要新建的对象。标准的双判写法，同步锁和锁内的判断保证了单例只会生成一个对象。锁外的判断保证了在对象生成之后不必要再次的加锁解锁消耗。变量前的volatile保证了对该对象的写操作永远在读操作之前。</p>
<p>如上面的文章中所提到的，在使用单例的时候，99%的场景是使用已经生成的单例。为了提高性能，OC是不是也可以这么做？如果不这么做，就使用GCD常规的写法，有什么影响呢？</p>
<h6 id="于是我做了以下的实验…"><a href="#于是我做了以下的实验…" class="headerlink" title="于是我做了以下的实验…"></a>于是我做了以下的实验…</h6><h5 id="第一个实验"><a href="#第一个实验" class="headerlink" title="第一个实验"></a>第一个实验</h5><p>计算dispatch_once的耗时。由于单次耗时具有很大的不确定性。这里我对dispatch_once操作进行了五十万次，并且计算了平均值。</p>
<p>时间计算方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">CGFloat BNRTimeBlock (void (^block)(void)) &#123;</div><div class="line">    mach_timebase_info_data_t info;</div><div class="line">    if (mach_timebase_info(&amp;info) != KERN_SUCCESS) return -1.0;</div><div class="line">    </div><div class="line">    uint64_t start = mach_absolute_time ();</div><div class="line">    block ();</div><div class="line">    uint64_t end = mach_absolute_time ();</div><div class="line">    uint64_t elapsed = end - start;</div><div class="line">    </div><div class="line">    uint64_t nanos = elapsed * info.numer / info.denom;</div><div class="line">    return (CGFloat)nanos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;&#125;);</div><div class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class="line">        int i = 1000000;</div><div class="line">        int j = i;</div><div class="line">        double total = 0;</div><div class="line">        while (j) &#123;</div><div class="line">            double mm = BNRTimeBlock(^&#123;</div><div class="line">                dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">            if (i != j) &#123;</div><div class="line">                total = total + mm;</div><div class="line">            &#125;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        NSLog(@&quot;total%f&quot;,total / i);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>平均时间：40 ns</p>
<h5 id="第二个实验"><a href="#第二个实验" class="headerlink" title="第二个实验"></a>第二个实验</h5><p>改变条件，增加线程数量，每个线程并发执行。每次执行完成增加一个睡眠时间，加大冲突的概率。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;&#125;);</div><div class="line">    for (int o = 0; o &lt; 4; o ++) &#123;</div><div class="line">        dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class="line">            </div><div class="line">            int i = 5000000;</div><div class="line">            int j = i;</div><div class="line">            double total = 0;</div><div class="line">            while (j) &#123;</div><div class="line">                double mm = BNRTimeBlock(^&#123;</div><div class="line">                    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">                        BOOL i = 0;</div><div class="line">                    &#125;);</div><div class="line">                &#125;);</div><div class="line">                if (i != j) &#123;</div><div class="line">                    total = total + mm;</div><div class="line">                &#125;</div><div class="line">                j--;</div><div class="line">                sleep(0.5);</div><div class="line">            &#125;</div><div class="line">            NSLog(@&quot;total%f&quot;,total / i);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>4个线程执行的平均耗时分别是：40.28ns、41.70ns、40.36ns、41.18ns</p>
<p>可见dispatch_once在多线程高冲突的环境下依旧可以保持良好的性能。</p>
<h5 id="第三个实验"><a href="#第三个实验" class="headerlink" title="第三个实验"></a>第三个实验</h5><p>dispatch_once在执行完成之后会将onceToken置为-1，表示已经执行过。那么类似java的双判写法，也在dispatch_once外面加一个判断。测试单线程五十万次的时间:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">double mm = BNRTimeBlock(^&#123;</div><div class="line">                    if (onceToken != -1) &#123;</div><div class="line">                        dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">                            BOOL i = 0;</div><div class="line">                        &#125;);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div></pre></td></tr></table></figure>
<p>执行的平均时间是：23.42 ns</p>
<h5 id="第四个实验"><a href="#第四个实验" class="headerlink" title="第四个实验"></a>第四个实验</h5><p>同样的，对第三个实验进行多线程的测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;&#125;);</div><div class="line">    </div><div class="line">    for (int o = 0; o &lt; 4; o ++) &#123;</div><div class="line">        dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class="line">            int i = 5000000;</div><div class="line">            int j = i;</div><div class="line">            double total = 0;</div><div class="line">            while (j) &#123;</div><div class="line">                double mm = BNRTimeBlock(^&#123;</div><div class="line">                    if (onceToken != -1) &#123;</div><div class="line">                        dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">                            BOOL i = 0;</div><div class="line">                        &#125;);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">                if (i != j) &#123;</div><div class="line">                    total = total + mm;</div><div class="line">                &#125;</div><div class="line">                j--;</div><div class="line">                sleep(0.5);</div><div class="line">            &#125;</div><div class="line">            NSLog(@&quot;total%f&quot;,total / i);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>4个线程执行的平均耗时分别是：22.37ns、22.68ns、22.17ns、21.73ns</p>
<p>实验中可以看到如果不增加判断的话，耗时基本上是增加判断的两倍左右。由于苹果GCD优化的非常好，这一点小改动的优化级别是在纳秒。但是在大型应用，尤其是单例管理类众多的应用中，优化效果还是很可观的。毕竟积少成多，没有最快，只有更快。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/31/ios-10九宫格输入法问题/" itemprop="url">
                  iOS 10九宫格输入法问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-31T12:47:49+08:00" content="2016-10-31">
              2016-10-31
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>iOS 中在聊天输入框中输入@符号弹出选择@的联系人列表。</p>
</blockquote>
<h6 id="问题简述"><a href="#问题简述" class="headerlink" title="问题简述"></a>问题简述</h6><p>一般来说，我们对此的做法是，实现UITextViewDelegate协议，在shouldChange里面决定对用户本次输入的内容的监听。在检测到输入@的时候弹出选择界面。</p>
<h6 id="问题触发"><a href="#问题触发" class="headerlink" title="问题触发"></a>问题触发</h6><p>在 iOS10 上使用自带的九宫格输入法，选择符号按钮，输入英文的@。</p>
<h6 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h6><p>使用九宫格输入法的时候，点击符号按钮，会自动输入一个“，”，随后选择其他符号的时候就会覆盖这个“，”。</p>
<p>在iOS 9以及之前，在shouldChange的时候就会携带三个参数，一个是当前输入内容变化的textView,一个是内容变化的range，还有一个是变化的内容NSString。range中position为当前内容变化的位置，length为变化的长度。在上述情况下，iOS 9会有两次回调，第二次输入@的回调中range中的length为1，NSString 为“@”。</p>
<p>在iOS10 ，一共收到3次回调，第一次是输入“，”，输入@的时候会连续回调两次。第一次 length为1，NSString为“@”，但是实现结果不是替换了“，”，而是删除了“@”。第二次length为 0 ，NSString 为“@”，实现结果是增加一个@符。</p>
<h6 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h6><p>我不理解为什么iOS10 要这么做，有可能是iOS10 的一个bug吧。想要绕过这个问题，不能简单的由range中的length和@来区分iOS 10 中的问题。因为我们还要兼容到iOS9。</p>
<p>在最终的解决方案中，我们首先在shouldChange中判断NSString 是不是@符，如果是那么再看length是不是1，如果是就记录本次替换之后的，即把“，”替换为“@”之后的字符串。如果是iOS10的话就会有第二次回调，回调的时候比较当前textview中的字符串和上次记录的。如果不一致，那就说明上次替换是失败的。这样就可以识别出两次回调的中的第二次了。</p>
<p>注：在回调中必须都是返回YES，不控制是否更改。由它自己去改变。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/12/CodeSign/" itemprop="url">
                  iOS 证书与代码签名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-12T21:39:43+08:00" content="2016-10-12">
              2016-10-12
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在接触到iOS的第一天遇到的最蛋疼的事情就是证书与签名。莫名其妙安装了一个带密码的.p12文件，然后项目里面还不能运行，折腾了半天，换了个Bundle ID,选了个证书。所以我花了一天的时间，深入仔细地研究了一下这个证书和签名到底是什么玩意~</p>
</blockquote>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>在进入主题之前，需要知道、了解以下两类算法</p>
<h4 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h4><p>摘要算法是iOS签名认证过程中不可或缺的一类算法。它可以将任意长度的文本或者字节数据转换成一个固定长度的文本。并且:</p>
<ol>
<li><p>只要源不一致，计算结果必然不同。</p>
</li>
<li><p>无法逆向。<br>典型算法：MD5,SHA等</p>
</li>
</ol>
<h4 id="加密算法——非对称加密算法"><a href="#加密算法——非对称加密算法" class="headerlink" title="加密算法——非对称加密算法"></a>加密算法——非对称加密算法</h4><p>如果说摘要算法是不可或缺的，那么非对称加密算法作为世界上最重要的算法，已然是作为iOS签名认证的核心了。非对称加密算法有以下的特点：</p>
<ul>
<li><p>对于一个私钥，有且只有一个与之对应的公钥。生成者负责生成私钥和公钥，并保存私钥，公开公钥</p>
</li>
<li><p>公钥是公开的，但不可能通过公钥反推出私钥，或者说极难反推，只能穷举，所以只要密钥足够长度，要通过穷举而得到私钥，几乎是不可能的</p>
</li>
<li><p>通过私钥加密的密文只能通过公钥解密，公钥加密的密文只有通过私钥解密</p>
</li>
</ul>
<p>典型算法：RSA</p>
<p>以上简单介绍一下两个重要的算法，详细的算法说明见百度;接下来就需要看一下另一个重要的概念:</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>首先要明确的是数字签名是做什么的？数字签名是用来验证数据的完整性和可靠性的。何为完整性？就是保证数据不被三方所篡改。何为可靠性？就是保证数据是确定由对方发送的。</p>
<p>数字签名就是以上两者实现的一个结合。例如:我们有一个大文本需要去发送给对方，首先我们会对文本进行摘要算法，得到摘要。然后，对这个摘要使用自己的私钥加密，最后再将文本，加密后的密文以及公钥一起发送给对方。<br>对方拿到数据之后，将密文用对方的公钥解密。然后将对方发来的数据再次使用摘要算法获取摘要。将解密之后的摘要和计算得到的摘要进行比对。前一个步骤是验证数据的可靠性也称为不可抵赖性（即数据由对方发送），后一步是验证数据的完整性。</p>
<p>而这个获取摘要然后加密的过程就称之为“数字签名”。</p>
<h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>有这么一个情况，如果数据在发送过程中，其中的公钥被人替换了，那么不就没有人能够验证数据了？始终认为数据是不可靠不完整的？</p>
<p>这个时候就需要有一个方法去保证这个公钥的可靠性，那就是数字证书。</p>
<p>数字证书就是由一些称之为认证机构的颁发给你的电子证书，这个证书里面包含你的公钥和一些信息。有人说，这有什么特别的。特别的就在于，这些认证机构会对这个证书使用机构的私钥签名。<br>在操作系统中会有几个默认的证书，被称之为根证书，这些机构被称为Root CA.你就可以用这些根证书中的公钥去获取证书中的对方的公钥，如果能解开，那说明这个是可信的。而我们的证书就是由苹果CA颁发的。使用苹果颁发给我们的证书，才会被Xcode所信任。</p>
<p>所有的基本知识已经介绍完了，下面开始正题…</p>
<hr>
<h3 id="第一步-——数字证书"><a href="#第一步-——数字证书" class="headerlink" title="第一步   ——数字证书"></a>第一步   ——数字证书</h3><p>说了半天，最重要的就是要有证书咯？好了，我们通过网上一系列的操作，开始获取证书。</p>
<p><img src="http://7xqmjb.com1.z0.glb.clouddn.com/20161012147627833364478.jpg?imageView2/0/format/jpg" alt="jpg"></p>
<p>Mac OS在钥匙串访问中就可以请求证书,如上图。点击成功保存之后赫然写了：证书请求创建成功，这才发现这根本不是证书。这个时候本地多了一个名为CertificateSigningRequest.certSigningRequest 的文件。先用openssl看看这个里面到底是什么？</p>
<p><img src="http://7xqmjb.com1.z0.glb.clouddn.com/20161012147627863014883.jpg?imageView2/0/format/jpg" alt="20161012147627863014883.jpg"></p>
<p>细细地看一下，这里面包含了这几样东西</p>
<ol>
<li><p>申请者信息，用申请者的私钥加密</p>
</li>
<li><p>申请者公钥，申请者使用的私钥对应的公钥</p>
</li>
<li><p>摘要算法和公钥加密算法</p>
</li>
</ol>
<p>然后在苹果MC中申请证书的时候苹果就会要求上传SCR，上传成功之后遍终于拿到了传说中的证书。</p>
<p>我们使用openssl看一下证书中的内容:</p>
<p><img src="http://7xqmjb.com1.z0.glb.clouddn.com/201610135809059CB73A1-EE8A-41CB-88BE-A88C9F9D20E5.png" alt="201610135809059CB73A1-EE8A-41CB-88BE-A88C9F9D20E5.png"></p>
<p>这是一个遵守x.509编码规范的数字证书。和其他x.509结构一样，证书中主要包括了两个域：data和Signature Algorithm,其中data域是证书中的内容，Signature Algorithm是苹果的CA的公钥。</p>
<p>data域中又主要包括：Signature Algorithm,Issuer,Validity,Subject,Subject Public Key Info和X.509的扩展字段。代表的意思分别是被颁发者的签名算法，颁发机构的信息，有效期，被颁发者的信息，被颁发者的公钥。（具体的内容可以去看x.509的规范）</p>
<p>换句话简单的来说，苹果从上传的CSR文件中取出了公钥，并且加入了申请者的信息，然后在最后BEGIN CERTIFICATE后加上了Apple CA的签名之后的文本，就构成了这个数字证书。</p>
<p>OK，这个时候我们已经拿到证书了，双击安装。注意这个时候安装的机子必须是和刚刚生成CSR文件的机子是同一台，因为在生成CSR的时候本地会保留生成公钥和所对应的私钥。而安装证书的时候，系统就会自动匹配，以把刚刚生成的私钥和证书中的公钥相对应。也就是说，此时此刻，只有这台机子上是有相对应的公私钥的，其他任何地方最多只有公钥。我们可以看到在钥匙串中是这样的，注意是有个小三角可以展开的：</p>
<p><img src="http://7xqmjb.com1.z0.glb.clouddn.com/20161013727015856F31C-CF9B-4BA2-82EE-3D5DAFB31FE3.png" alt="20161013727015856F31C-CF9B-4BA2-82EE-3D5DAFB31FE3.png"></p>
<p>如果需要团队开发怎么办？一般来说我们都会把这个证书和对应的私钥备份一下。在keychain中选中证书和三角展开中的私钥，右击保存到本地，这个就是我在本文摘要中提到的.p12了。在其他机子上安装之后会自动安装证书和相对应的私钥。（注意备份的时候不要漏了私钥）</p>
<p>这样的话，我们在使用Xcode编译打包的时候就会根据我们选择的证书（这个有误之后解释）去使用证书对应的私钥进行签名。</p>
<p>苹果的证书有很多种，但是由上面的理论可以得出，只要我们给出的CSR是同一个，也就是说公钥不变，那么苹果给我们的证书中的公钥也是不会变的。苹果之所以区分这么些个证书，只是为了让开发者在不同的环境，不同的阶段使用不同的证书。</p>
<p>第一步完成了，但是这个还只是麻烦事儿的刚刚开始……</p>
<h3 id="第二步-——描述文件-mobileprofile"><a href="#第二步-——描述文件-mobileprofile" class="headerlink" title="第二步   ——描述文件(.mobileprofile)"></a>第二步   ——描述文件(.mobileprofile)</h3><p>回过头来想一下，我们要证书是为了什么？1.保证这个App是完整的，没有被别人改过。2.保证这个App是安全的（具体的安全标准就要看怎么去定义了）。那么问题来了，苹果怎么去保证，这个APP是否有权限接入苹果的某些服务呢？于是，就有了.mobileprofile，但是这只是.mobileprofile 的一个功能。</p>
<p>.mobileprofile也是从MC中申请的。事实上我们在Xcode中编译打包的时候不论是debug,release还是distrbution，首要选择的就是provision profile，然后再选择证书。</p>
<p>说到这里可能有些明白了，我们先看一下这个文件里面有什么。使用苹果自带的security命令查看。</p>
<p><img src="http://7xqmjb.com1.z0.glb.clouddn.com/20161013147634122120744.jpg?imageView2/0/format/jpg" alt="20161013147634122120744.jpg"></p>
<p>内容很多，我们慢慢看：<br>可以看到，文件是xml形式的文档类文件。仔细看文件内容都是以键值对形式出现的。内容包括：AppIdName, ApplicationIdentifierPrefix, CreationDate,Platform, DeveloperCertificates, Entitlements, ExpirationDate, Name, ProvisionedDevices, LocalProvision, TeamIdentifier, TeamName, TimeToLive, UUID, Version. 内容看起来好像很多。有些很容易懂，这里具体说明几个比较重要的。</p>
<ol>
<li><p>app对应的ID，这个是在MC中创建应用的时候必须创建的。</p>
</li>
<li><p>app可以使用的证书。之前有说，一个应用可以有多个证书。而DeveloperCertificates下的array标签中就包含了这个app所有可以选择的证书。其中第二个就是我们之前的那个证书（因为证书是基于base64，符合pem编码格式）。</p>
</li>
<li><p>功能授权列表。Entitlements 下的标签就是当前App所授权的功能。上图中就包含：钥匙串，其中的array就是KeychainAccessGroups.plist文件下的array；get-task-allow：调试开关，如果打开，则允许Xcode连接到应用进行调试，如果是发布版的profile一般是关闭的。</p>
</li>
<li><p>允许调试的设备ID。ProvisionedDevices 下列出了所有允许安装的设备列表。</p>
</li>
<li><p>苹果的签名。这里的签名和数字签名不太一样，.mobileprovision文件是一个根据密码讯息语法 (Cryptographic Message Syntax) 加密的文件（下文中会简称 CMS）。如果你处理过 S/MIME 邮件或者证书你会对这种加密比较熟悉，详细信息可以查看互联网工程任务组 (IETF) 制定的 RFC3852。某些版本的openssl可以查看，但是mac自带的不行，这也就是为什么我们要用security而不是openssl。总之这个文件只有苹果能够生成，并且我们无法修改，也就是苹果控制了以上所有的参数。</p>
</li>
</ol>
<p>如第5点所说，这个文件是由苹果签名的，一旦其中的任何一个参数需要做一些改动的时候我们就需要从MC中重新配置，并且重新替换掉原来的配置文件。</p>
<h3 id="第三步-——Xcode7签名问题"><a href="#第三步-——Xcode7签名问题" class="headerlink" title="第三步   ——Xcode7签名问题"></a>第三步   ——Xcode7签名问题</h3><p>关于签名的介绍几本结束了，但是关于Xcode7版本的代码签名还是有几点疑问需要解释一下。</p>
<ol>
<li>Xcode7推出了无需证书即可在真机上调试，这个是怎么做到的，而且不需要申请证书？</li>
</ol>
<p><img src="http://7xqmjb.com1.z0.glb.clouddn.com/20161014306278C93E06F-F793-49A7-A108-5CA3E0479C07.png" alt="20161014306278C93E06F-F793-49A7-A108-5CA3E0479C07.png"><br>在Xcode7 的设置中添加自己的AppId账号之后，选择自己的team，点击fix issue，之后就可以编译签名了。</p>
<p>Xcode具体是怎么做的？Xcode先检测本地有没有证书。如果没有，创建证书申请CSR,然后向MC申请证书，在本地创建安装证书，然后再向MC请求生成provision profile，请求的同时会把本地的证书上传。如果有证书了，那么还要验证一下当前的连接的调试设备是不是在描述文件中。如果不在，就需要再次请求替换新的描述文件。所以其实并不是无需证书，而是Xcode自动去创建管理了。</p>
<p>Xcode下载后的文件由Xcode自己去管理的，如上图。右击之后我们可以在finder中显示，所有的文件都在/Users/用户名/Library/MobileDevice/Provisioning Profiles 目录下管理，可以看到所有的文件命名都是无规则的。并且这些描述文件的有效期都很短！</p>
<ol>
<li>那这个文件和我们在MC中手动上传和下载的描述文件是不是一致的呢？</li>
</ol>
<p>答案是否定的。我们在编译签名的地方手动选择Xcode管理的这些描述文件，Xcode报错。如下图，大致的意思就是这个文件是由Xcode管理的，签名需要一个手动管理的文件。这个手动管理的文件其实就是我们需要自己从MC中生成、下载。</p>
<p><img src="http://7xqmjb.com1.z0.glb.clouddn.com/20161014655927A179002-05AE-42D8-BC02-404AF25E76DE.png" alt="20161014655927A179002-05AE-42D8-BC02-404AF25E76DE.png"></p>
<p>回到第二步，我们在列出.mobileprofile中内容的时候，有一个字段为LocalProvision，值为true。看到这里就明白了，这个字段就是用来标记这个证书是不是由Xcode申请、下载、管理的。如果我们使用MC中手动下载的，那便没有这个字段。</p>
<h3 id="第四步-——iOS的签名"><a href="#第四步-——iOS的签名" class="headerlink" title="第四步   ——iOS的签名"></a>第四步   ——iOS的签名</h3><p>关于签名和Xcode就是以上那么多了，现在我们看一下iOS到底是怎么去签名App的。</p>
<p>打包好的App是一个.ipa文件，把文件后缀改为zip便可以解压了。解压完成后，就是一个.app文件。先看一下这个应用的签名情况，签名是OK的。<br><img src="http://7xqmjb.com1.z0.glb.clouddn.com/201610142121740E4614A-6F90-49AF-8E06-A0E2E8C9C0F3.png" alt="201610142121740E4614A-6F90-49AF-8E06-A0E2E8C9C0F3.png"></p>
<p>然后右击显示包内容。<br><img src="http://7xqmjb.com1.z0.glb.clouddn.com/201610146617097DB8235-716B-42C9-8B90-90C26B2D6F8F.png" alt="201610146617097DB8235-716B-42C9-8B90-90C26B2D6F8F.png"></p>
<p>包中包含了：</p>
<ol>
<li>资源文件</li>
<li>文件_CodeSignature/CodeResources</li>
<li>可执行文件</li>
<li>mobileprovision文件，打包的时候加入。</li>
<li>Frameworks。程序引用的非系统自带的Frameworks，每个Frameworks其实就是一个app，其中的结构应该和app差不多，也包含签名信息CodeResources文件。（示例中没有）</li>
</ol>
<p>在_CodeSignature中含有一个CodeResources文件，打开文件：<br><img src="http://7xqmjb.com1.z0.glb.clouddn.com/2016101434890F49F0D8C-13C8-4BDA-8CAC-FE53E51A85B0.png" alt="2016101434890F49F0D8C-13C8-4BDA-8CAC-FE53E51A85B0.png"><br>这是一个plist文件。一共有四个大节点，rules，files,rules2,files2.前两者是兼容老版本，后两者是新版本。新版本无法排除不签名文件。files中包含了包中除了Frameworks和可执行文件在外的所有文件的签名，但是苹果似乎对此还做了一个类似base64的转码。rules是一些签名规则。</p>
<p>可执行文件和扩展是需要被单独签名的，并且他们的签名会被写入二进制文件。在验证签名的时候这两者和资源文件就要区分对待了。如下图，分别对包内的资源文件和可执行文件查看签名情况(资源文件显示未签名，可执行文件显示已签名)：<br><img src="http://7xqmjb.com1.z0.glb.clouddn.com/201610141672309FEF5FD-6F35-4CA4-BFB3-018865E67F89.png" alt="201610141672309FEF5FD-6F35-4CA4-BFB3-018865E67F89.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在iOS中，代码签名是必要的。这也是苹果能保证应用生态圈的一个重要环节。</p>
<p>接下来需要学习的应该是研究一下具体签名规则。包括本文中还有一些地方我并没有弄得很懂，例如不同文件的签名写入，写入签名对文件的影响，CodeResources中rules标签下的内容。这些可能需要去阅读一下<a href="https://github.com/maciekish/iReSign" target="_blank" rel="external">iReSign</a>源码了，这些可能会对设计自动打包有帮助</p>
<p>参考内容：</p>
<p><a href="http://www.cnblogs.com/ioriwellings/p/5066652.html" target="_blank" rel="external">漫谈iOS程序的证书和签名机制</a></p>
<p><a href="https://objccn.io/issue-17-2/" target="_blank" rel="external">代码签名探析</a></p>
<p><a href="http://blog.csdn.net/phunxm/article/details/42685597" target="_blank" rel="external">iOS Provisioning Profile(Certificate)与Code Signing详解</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/12/OC-Code/" itemprop="url">
                  OC代码规范
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-12T10:08:20+08:00" content="2016-10-12">
              2016-10-12
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="iOS高质量代码"><a href="#iOS高质量代码" class="headerlink" title=" iOS高质量代码"></a><center> iOS高质量代码</center></h1><h2 id="OC语言"><a href="#OC语言" class="headerlink" title="OC语言"></a>OC语言</h2><h4 id="多用类型常量，少用-define预处理指令"><a href="#多用类型常量，少用-define预处理指令" class="headerlink" title="多用类型常量，少用#define预处理指令"></a>多用类型常量，少用#define预处理指令</h4><p>&#8195;&#8195;<strong>理由：</strong>很多人都喜欢使用预定义指令去定义一些常量值，例如：<code>#define ANIMATION_DURATION 0.3</code>。预处理指令在编译期间就会把所有的字符串 ANIMATION_DURATION 都会替换成0.3。但是这样做的问题在于：1. 阅读代码的时候，或者调试的时候根本不知道这个值得类型是什么。2.值很容易出现在不该出现的地方（只要包含了头文件）。3.容易遭人修改。4.不易编写开发文档。</p>
<p>&#8195;&#8195;<strong>解决方案：</strong></p>
<ol>
<li>对内变量：使用定义静态常量变量。例如：<code>static const int key = 3;</code>如果不添加这个<code>static</code>那么编译器就会再创建一个<code>外部符号（external symbol）</code>。相反如果一个变量既声明为<code>static</code>又声明为<code>const</code>那么编译器就会像预定义处理一样替换值，但是这种方式是带有类型信息的。</li>
<li>对外变量：使用定义静态不可变扩展常量变量。例如：<code>entern NSString *const ECOLoginManagerDidLoginNotification</code> <code>NSString *const ECOLoginManagerDidLoginNotification = @&quot;ECOLoginManagerDidLoginNotification&quot;</code>前者在头文件中声明，后者在声明改变量的头文件相对应的实现文件中定义比去年一起会在生成目标文件时在<code>数据段</code>为字符串分配空间。此类常量将会放在一个<code>全局变量表</code>中，以便于在定义的编译单元之外的地方使用。</li>
</ol>
<p>&#8195;&#8195;<strong>命名规则：</strong>如果是在编译单元内有效，那么就以<code>k</code>开头。如果常量在类之外也是可见的，那么就以<code>类名</code>为前缀。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/12/UIViewController/" itemprop="url">
                  UIViewController 文档解读
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-12T10:06:49+08:00" content="2016-10-12">
              2016-10-12
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>&#8195;&#8195;一般来说我们都会很少去创建UIViewController的实例，而是创建UIViewController的子类的实例，然后使用这些子类来创建一些特定的行为或者可视化界面。</p>
<p>&#8195;&#8195;一个ViewController的主要职责包括：</p>
<ul>
<li>根据底层数据的变化来更新View的内容</li>
<li>响应用户交互</li>
<li>重新构建view并且管理布局的所有接口</li>
</ul>
<p>&#8195;&#8195;一个视图控制器和它所管理或者加入的一些视图View紧密关联。视图控制器也是一个UIResponder的对象，并且也被插入至它的rootView和rootView的superView的响应链中，这些View可以来自不同的视图控制器。如果在一个视图控制器中，没有任何一个View去响应这个时间，那么这个视图控制器可以选择去处理这个时间，或者将它传递到superView去。</p>
<h3 id="ViewManagerment"><a href="#ViewManagerment" class="headerlink" title="ViewManagerment"></a>ViewManagerment</h3><p>&#8195;&#8195;每个视图都管理着一个View层，而这个View层的根View将会被保存到这个类的view属性中。rootView就类似于这个View层中其它view的一个容器。window包含的那个viewController是整个App的根viewController并且它的大小是填满整个窗口的。<code>视图控制器对它的View是懒加载的。</code></p>
<h3 id="Important"><a href="#Important" class="headerlink" title="Important"></a>Important</h3><p>&#8195;&#8195;<code>一个视图控制器是它的view和任何它创建的subView的唯一个持有者。它负责创建这些view，并且在合适的时机丢弃它们，例如：在控制器本身被释放的的时候。当使用storyboard或者nib文件存储你的View的时候，每个控制器请求他们的时候，就会自动的拷贝一份这些view。然而如果你手动创建这些View的时候那么你也需要手动释放。并且你也不能在各个控制器中复用了。</code></p>
<h3 id="Handling-View-Rotations"><a href="#Handling-View-Rotations" class="headerlink" title="Handling View Rotations"></a>Handling View Rotations</h3><p>&#8195;&#8195;在iOS8之后，所有与旋转相关的方法已经全部弃用了。而旋转已经被看做是视图控制器中的<code>view size上的改变了</code>。因此现在已经全部使用<code>viewWillTransition(to:with:)</code>。当发生旋转的时候，UIKit首先会调用window窗口的根视图控制器的这个方法，然后这个视图控制器又会通知它的子视图控制器，以此按照视图控制器的层级传递下去。</p>
<pre><code>在iOS6和iOS7中，应用可以在app的Info.plist中定义支持的方向接口。你可以在一个ViewController中重写 supportedInterfaceOrientations 方法来限制当前的视图控制器所支持的屏幕方向种类。系统只会调用窗口的根视图控制器，或者是填满整个屏幕的视图控制器的方法，而使用了由父视图控制器提供的部分屏幕的子视图控制器便不再参与决定屏幕的方向。最终，应用在Info.plist中限定的屏幕方向列表和当前的视图控制器限定的列表的交集，便是这个视图控制器最终可以达到的方向。或者你可以直接重写 preferredInterfaceOrientationForPresentation 在控制器全屏显示的时候，直接会使用这个方法返回的方向类别。
在launch阶段，只有当application完成 application(_:didFinishLaunchingWithOptions:)方法返回的时候才会按照以上描述的机制去显示，在此之前都是竖屏显示。
</code></pre><h3 id="Implementing-a-Container-View-Controller"><a href="#Implementing-a-Container-View-Controller" class="headerlink" title="Implementing a Container View Controller"></a>Implementing a Container View Controller</h3><p>&#8195;&#8195;一个UIViewController的子类也可以作为一个容器类的视图控制器。一个容器类的视图控制器管理着这个控制器所包含的其他子视图控制器的内容展现。</p>
<p>&#8195;&#8195;容器视图控制器类必须要声明一个公开的接口来与子视图建立关系。通过建立一个耦合度低的容器，你的子视图控制器可以在你的容器中独立的实现它的一些逻辑行为，而不必关心容器的一些私有的细节。</p>
<p>&#8195;&#8195;<code>容器视图控制器必须在将子视图加入到视图控制器层之前将它与自己建立关系</code>。只有这样，iOS操作系统才能正确的将事件发送到这些子视图控制器和这些控制器所管理的view中去。<code>同样的，在它将子视图移除的时候，也要断开与父视图的联系</code>。为了断开这种联系，容器需要调用一些基类定义的方法，这些方法不是被容器类调用的，而是被容器实现使用来告诉子视图一些预期的容器行为。</p>
<pre><code>在创建一个容器类视图控制器的时候不强制要求实现覆盖任何方法。
根据默认的方式，旋转和显示回调都会自动的传递给子视图。你可以选择性的实现shouldAutomaticallyForwardRotationMethods() 和 shouldAutomaticallyForwardAppearanceMethods方法来自己控制这个。
</code></pre><h3 id="State-Preservation-and-Restoration"><a href="#State-Preservation-and-Restoration" class="headerlink" title="State Preservation and Restoration"></a>State Preservation and Restoration</h3><p>&#8195;&#8195;如果你在视图控制器的<code>restorationIdentifier</code>属性中指定了一个值，那么当应用转换到后台的时候系统就会要求这个视图控制器去编码它自己。当保存的时候，一个视图控制器会保存它包含的所有层级的并且包含有<code>restorationIdentifier</code>的View。视图控制器不会自动保存任何的状态。如果你实现了一个容器类的视图控制器，你必须自己实现所有子view的编码。并且每个子View都要有它唯一的<code>restorationIdentifier</code>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/12/BackgroundTask/" itemprop="url">
                  Background Execution
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-12T09:41:38+08:00" content="2016-10-12">
              2016-10-12
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="后台执行"><a href="#后台执行" class="headerlink" title=" 后台执行"></a><center> 后台执行</center></h2><p>&#8195;&#8195;当用户不在前台使用你的应用的时候，系统就会将它挪到后台状态。对于很多App而言，后台状态就是app在转向暂停路上的一个简短的过渡。暂停App有利于提升电池的寿命，并且它还可以让系统提供出更多的资源给用户正在关注的前台应用。</p>
<p>&#8195;&#8195;大多数应用都能够移至暂停状态，但是也有一些App可以有合法的原因而留在后台。比如说一个徒步旅行的应用，可能要一直用到用户的位置信息，这样可以在一个地图上绘制出用户所走过的路线。而一个音频类的App可能需要在锁屏界面一直播放音乐。其他应用可能需要在后台下载内容，以尽快展示给用户。当你发现你必须要让你的应用跑在后台的时候，iOS可以有效的帮助你并且不会剥夺应用的资源和用户的电池。这个技术会分成以下三种情况：</p>
<ul>
<li>应用在前台开始执行了一个短暂的任务，可以在应用移至后台的时候请求一段完成这个任务的时间。</li>
<li>在前台开始了下载任务应用，可以将这些下载任务托管给系统，因此，在应用下载的时候可以允许应用进入暂停或者终止。</li>
<li>需要在后台执行特殊任务的应用，可以声明他们对一个或者多个后台执行模式的支持。<br>&#8195;&#8195;尽量去避免做一些后台的任务，除非这些任务可以提示所有的用户体验。一个应用可能是因为用户启动了另一个应用或者因为用户锁屏而暂时不使用它了而被移至后台。在这两种情况之下，用户都会都会发信号给应用，告诉应用不要再做任何有意义的工作了。继续运行只会耗尽用户的电量，并且可能会导致用户退出你的应用。所以多考虑一下你的后台工作，尽你所能避免后台工作。</li>
</ul>
<h3 id="执行有限长的任务"><a href="#执行有限长的任务" class="headerlink" title="执行有限长的任务"></a>执行有限长的任务</h3><p>&#8195;&#8195;当App被移至后台的时候，系统希望他们能够尽快的进入非活动状态，这样系统就能够停止这些应用。但是如果你的应用正在执行任务的过程中，并且还需要一些额外的时间去完成任务。那么应用可以调用UIApplication对象的 beginBackgroundTaskWithName:expirationHandler:或者 beginBackgroundTaskWithExpirationHandler:方法来请求一些额外的执行时间。调用这两个中任何一个方法都会系统推迟应用进入停止状态，并且给予应用一定的额外时间去完成任务。但是如果应用一旦完成任务，你必须要调用endBackgroundTask:方法来告诉系统应用已经完成了任务，可以进入停止状态了。</p>
<p>&#8195;&#8195;每次调用beginBackgroundTaskWithName:expirationHandler:或者 beginBackgroundTaskWithExpirationHandler:方法的时候都会生成一个独一无二的token与相应的task相关联。当你的应用结束任务的时候，必须调用endBackgroundTask:方法。如果不调用，那么就会导致应用的终止。如果你在开始执行任务的时候就提供了一个结束的handler，那么系统就会回调这个handler并且给你最后一次机会来结束任务从而避免终止。</p>
<p>&#8195;&#8195;你不必要等到应用已经被移至后台的时候再去指定后台任务。更好的设计是在开始任务之前就调用beginBackgroundTaskWithName:expirationHandler:或者beginBackgroundTaskWithExpirationHandler: 方法，在任务一结束的时候就调用endBackgroundTask：方法。你甚至可以在应用还在前台的时候就去采用这种模式。</p>
<p>&#8195;&#8195;在以下代码实例中，展示了如何当应用切换至后台的时候，去启动一个长任务。在这个例子中，请求开始一个后台长任务包含了一个终止的handler，以防止任务超时。任务被提交到一个异步的调度队列，所以方法applicationDidEnterBackground: 可以正常返回。block区块的使用简化了需要保持指向一些重要指针引用的代码，例如这个task本身。这个bgTask值是这个类的一个成员变量，保存了指向当前后台任务的标识的指针，并且在这个方法里做了初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)applicationDidEnterBackground:(UIApplication *)application</div><div class="line">&#123;</div><div class="line">    bgTask = [application beginBackgroundTaskWithName:@&quot;MyTask&quot; expirationHandler:^&#123;</div><div class="line">        // Clean up any unfinished task business by marking where you</div><div class="line">        // stopped or ending the task outright.</div><div class="line">        [application endBackgroundTask:bgTask];</div><div class="line">        bgTask = UIBackgroundTaskInvalid;</div><div class="line">    &#125;];</div><div class="line">    // Start the long-running task and return immediately.</div><div class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">        // Do the work associated with the task, preferably in chunks.</div><div class="line">        </div><div class="line">        </div><div class="line">        [application endBackgroundTask:bgTask];</div><div class="line">        bgTask = UIBackgroundTaskInvalid;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#8195;&#8195;<code>最好习惯性的提供一个终止handler，如果你需要知道你的应用还剩余多少执行的时间，你可以调用UIApplication的backgroundTimeRemaining属性</code></p>
<p>&#8195;&#8195;在处理终止的handler中，你可以添加一些额外的代码来结束你的任务。然而，你增加的任何的代码，一定不能执行太久，因为你的处理终止的handler被调用的时候，你的应用已经是接近于应用剩余时间的极限了。所以，只能执行尽量最少的状态信息保存并且结束任务。</p>
<h3 id="在后台下载内容"><a href="#在后台下载内容" class="headerlink" title="在后台下载内容"></a>在后台下载内容</h3><p>&#8195;&#8195;当下载文件的时候，应用需要使用一个<code>NSURLSession</code>对象来启动下载任务。只有这样系统才能控制下载线程，以防止应用被暂停或者被终止。当你为后台传输配置一个<code>NSURLSession</code>对象的时候，系统会在一个独立的线程里面管理这些传输，并且用常规的方法将下载状态返回给应用。如果你的应用在传输过程中终止了，那么系统会在后台继续传输并且在某些情况下，当传输完成了或者当其中的一个或者多个任务需要告知你的时候就会启动App。</p>
<p>&#8195;&#8195;为了支持后台传输，你必须要合适的配置你的<code>NSURLSession</code>。你需要创建一个<code>NSURLSessionConfiguration</code>并且设置几个合适的属性值。然后你就能在你创建session的时候就将配置对象传递给<code>NSURLSession</code>的合适的初始化方法了。</p>
<p>&#8195;&#8195;创建一个支持后台下载的配置对象步骤如下：</p>
<ol>
<li>使用<code>NSURLSessionConfiguration</code>的<code>backgroundSessionConfigurationWithIdentifier:</code>方法创建一个配置对象。</li>
<li>设置配置对象的<code>sessionSendsLaunchEvents</code>属性的值为YES。</li>
<li>如果你的应用在前台就开始传输，那么建议你设置<code>discretionary</code>属性的值为YES。</li>
<li>合适地配置其他的属性。</li>
<li>使用配置对象创建你的<code>NSURLSession</code>对象</li>
</ol>
<p>&#8195;&#8195;一旦配置好了，你的NSURLSession就会在合适的时机将上传和下载任务递交给操作系统。如果当你的任务完成的时候，你的应用还在运行中（不论是前台还是后台），那么session就会以常用的方式通知到它的代理。如果任务还没有完成时候，系统终止了你的程序，那么系统就会自动管理后台的任务。如果用户终止了你的程序，那么系统就会取消所有等待的任务。<br>&#8195;&#8195;当所有的和后台session相关的任务都完成了，系统就会重新启动已经终止的应用（取决于 <code>sessionSendsLaunchEvents</code> 属性是不是被设置为YES，并且用户没有强制退出应用），并且会调用应用代理的 <code>application:handleEventsForBackgroundURLSession:completionHandler:</code>方法(系统可能也会重新启动应用来处理授权问题或者其他需要应用关注的与任务相关的事件)。在你实现的代理方法中，你可以使用之前提供的标识和相同的配置来创建一个新的NSURLSessionConfiguration和一个NSURLSession对象。系统会将你新创建的session对象和之前的任务与状态报告进行连接。</p>
<h3 id="实现长运行任务"><a href="#实现长运行任务" class="headerlink" title="实现长运行任务"></a>实现长运行任务</h3><p>因为有些任务要求更多的只想时间，你必须请求特殊的权限来在后台运行而不被终止，在iOS中，只有特殊的App类型才被允许在后台运行。</p>
<ul>
<li>在后台播放音频类型文件的App，例如音乐播放App</li>
<li>在后台录制音频类型文件的App</li>
<li>在任何时刻都要让用户知道当前位置的应用，例如导航类App</li>
<li>支持使用网络流的语音通话VoIP的App</li>
<li>需要定期下载执行新的内容的App</li>
<li>需要定期接收更新新内容的扩展附件的App</li>
</ul>
<p>&#8195;&#8195;实现那些服务的App必须在他们支持和使用系统框架的时候去声明这些服务。让系统知道，你的应用支持那些服务，但是在某些情况下，系统框架确实会让你的应用不被终止。</p>
<p>##声明应用支持的后台任务<br>需要使用并且支持后台任务的应用必须提前声明这些服务。在Xcode5或者更高版本中，你可以在你的应用设置中的功能选项卡中声明你的应用支持的后台模式。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7xqmjb.com1.z0.glb.clouddn.com/2016091443690u=1172000421,752760050&fm=116&gp=0.gif"
               alt="Caio" />
          <p class="site-author-name" itemprop="name">Caio</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Caio</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

</body>
</html>
